from starkware.cairo.common.alloc import alloc
from starkware.cairo.common.pow import pow

from stark_verifier.air.air_instance import AirInstance, DeepCompositionCoefficients
from stark_verifier.air.transitions.frame import EvaluationFrame
from stark_verifier.channel import Table
from stark_verifier.utils import Vec

struct DeepComposer {
    cc: DeepCompositionCoefficients,
    x_coordinates: felt*,
    z_curr: felt,
    z_next: felt,
}

func deep_composer_new{
    range_check_ptr
}(
    air: AirInstance,
    query_positions: felt*,
    z: felt,
    cc: DeepCompositionCoefficients,
) -> DeepComposer {
    alloc_locals;
    
    let g = air.trace_domain_generator;
    let g_lde = air.lde_domain_generator;
    let domain_offset = 3;

    // TODO: Don't hardcode the number of query positions here
    let (x_coordinates: felt*) = alloc();
    <% for (var i=0; i<54; i++) { %>
    let (x) = pow(g_lde, query_positions[<%= i %>]);
    let x = x * domain_offset;
    assert x_coordinates[<%= i %>] = x;
    <% } %>

    let z_curr = z;
    let z_next = z * g;

    let res = DeepComposer(
        cc,
        x_coordinates,
        z_curr,
        z_next,
    );
    return res;
}

func compose_trace_columns(
    composer: DeepComposer,
    queried_main_trace_states: Table,
    queried_aux_trace_states: Table,
    ood_main_frame: EvaluationFrame,
    ood_aux_frame: EvaluationFrame,
) -> felt* {

    let (result: felt*) = alloc();

    // Main trace coefficient rows
    let n_cols = queried_main_trace_states.n_cols;
    let cc_trace_curr = composer.cc.trace.values;
    let cc_trace_next = composer.cc.trace.values + n_cols;

    let z_curr = composer.z_curr;
    let z_next = composer.z_next;

    // Compose columns of the main segment
    // TODO: Don't hardcode the number of query and columns
    tempvar n = 54;
    let curr = queried_main_trace_states.elements;
    let next = (queried_main_trace_states.elements + n_cols);
    tempvar curr_ptr = curr;
    tempvar next_ptr = next;
    tempvar x_coord_ptr = composer.x_coordinates;
    tempvar result_ptr = result;
    loop_main:
        tempvar sum_curr = 0;
        tempvar sum_next = 0;
        <% for (var j=0; j<33; j++) { %>
        tempvar sum_curr = sum_curr + ([curr_ptr] - ood_main_frame.current[<%= j %>]) * cc_trace_curr[<%= j %>];
        tempvar sum_next = sum_next + ([next_ptr] - ood_main_frame.next[<%= j %>]) * cc_trace_next[<%= j %>];
        <% } %>
        tempvar x = [x_coord_ptr];
        tempvar sum = sum_curr / (x - z_curr) + sum_next / (x - z_next);
        assert [result_ptr] = sum;

        tempvar n = n - 1;
        tempvar curr_ptr = curr_ptr + 1;
        tempvar next_ptr = next_ptr + 1;
        tempvar x_coord_ptr = x_coord_ptr + 1;
        tempvar result_ptr = result_ptr + 1;
    jmp loop_main if n != 0;
    
    // Aux trace coefficient rows
    let n_cols = queried_aux_trace_states.n_cols;
    let cc_trace_curr = cc_trace_next;
    let cc_trace_next = cc_trace_next + n_cols;

    // Compose columns of the aux segments
    let curr = queried_aux_trace_states.elements;
    let next = (queried_aux_trace_states.elements + n_cols);
    tempvar curr_ptr = curr;
    tempvar next_ptr = next;
    tempvar x_coord_ptr = composer.x_coordinates;
    tempvar result_ptr = result;
    loop_aux:
        tempvar sum_curr = 0;
        tempvar sum_next = 0;
        <% for (var j=33; j<51; j++) { %>
        tempvar sum_curr = sum_curr + ([curr_ptr] - ood_aux_frame.current[<%= j %>]) * cc_trace_curr[<%= j %>];
        tempvar sum_next = sum_next + ([next_ptr] - ood_aux_frame.next[<%= j %>]) * cc_trace_next[<%= j %>];
        <% } %>
        tempvar x = [x_coord_ptr];
        tempvar sum = sum_curr / (x - z_curr) + sum_next / (x - z_next);
        assert [result_ptr] = sum;

        tempvar n = n - 1;
        tempvar curr_ptr = curr_ptr + 1;
        tempvar next_ptr = next_ptr + 1;
        tempvar x_coord_ptr = x_coord_ptr + 1;
        tempvar result_ptr = result_ptr + 1;
    jmp loop_aux if n != 0;

    let (data: felt*) = alloc();
    return data;
}

func compose_constraint_evaluations(
    composer: DeepComposer, queried_evaluations: Table, ood_evaluations: Vec
) -> felt* {
    // TODO
    let (data: felt*) = alloc();
    return data;
}

func combine_compositions(
    composer: DeepComposer, t_composition: felt*, c_composition: felt*
) -> felt* {
    // TODO
    let (data: felt*) = alloc();
    return data;
}
