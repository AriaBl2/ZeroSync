from starkware.cairo.common.alloc import alloc
from stark_verifier.air.air_instance import AirInstance, ConstraintCompositionCoefficients
from stark_verifier.air.transitions.frame import (
    EvaluationFrame,
    evaluate_transition,
    evaluate_aux_transition,
)

// TODO: Functions to evaluate transitions and combine evaluation should be autogenerated
// from a constraint description language instead of hand-coded.
func evaluate_constraints(
    air: AirInstance,
    constraint_coeffs: ConstraintCompositionCoefficients,
    ood_main_trace_frame: EvaluationFrame,
    ood_aux_trace_frame: EvaluationFrame,
    aux_trace_rand_elements: felt*,
    z: felt,
) -> felt {
    alloc_locals;

    // Evaluate main trace
    let (t_evaluations1: felt*) = alloc();
    evaluate_transition(
        ood_main_trace_frame, 
        t_evaluations1,
    );

    // Evaluate auxiliary trace
    let (t_evaluations2: felt*) = alloc();
    evaluate_aux_transition(
        ood_main_trace_frame,
        ood_aux_trace_frame, 
        aux_trace_rand_elements,
        t_evaluations2,
    );

    // Combine evaluations
    let result = combine_evaluations(
        t_evaluations1,
        t_evaluations2,
        z,
        air,
        constraint_coeffs,
    );

    // 2 ----- evaluate boundary constraints ------------------------------------------------------
    // TODO

    return result;
}

func combine_evaluations(
    t_evaluations1: felt*,
    t_evaluations2: felt*,
    x: felt,
    air: AirInstance,
    constraint_coeffs: ConstraintCompositionCoefficients,
) -> felt {
    // Degrees needed to compute adjustments
    tempvar composition_degree = air.context.trace_length * air.ce_blowup_factor;
    tempvar divisor_degree = air.context.trace_length - 1;
    tempvar target_degree = composition_degree + divisor_degree;

    // Evaluate divisor
    tempvar numerator = pow(x, air.context.trace_length);
    tempvar denominator = x - air.context.trace_length;
    tempvar z = numerator / denominator;

    // Sum all constraint evaluations
    tempvar sum = 0;

    // Merge evaluations for degree 1 constraints
    tempvar evaluation_degree = composition_degree - air.context.trace_length;
    tempvar degree_adjustment = target_degree - evaluation_degree;
    tempvar xp = pow(x, degree_adjustment);
    tempvar sum = sum + (constraint_coeffs.transition_a[15] + constraint_coeffs.transition_b[15] * xp) * t_evaluations_1[15]

    // Merge evaluations for degree 2 constraints
    tempvar evaluation_degree = composition_degree - 2 * air.context.trace_length;
    tempvar degree_adjustment = target_degree - evaluation_degree;
    tempvar xp = pow(x, degree_adjustment);
    tempvar sum = sum + (constraint_coeffs.transition_a[0] + constraint_coeffs.transition_b[0] * xp) * t_evaluations_1[0]
    tempvar sum = sum + (constraint_coeffs.transition_a[1] + constraint_coeffs.transition_b[1] * xp) * t_evaluations_1[1]
    tempvar sum = sum + (constraint_coeffs.transition_a[2] + constraint_coeffs.transition_b[2] * xp) * t_evaluations_1[2]
    tempvar sum = sum + (constraint_coeffs.transition_a[3] + constraint_coeffs.transition_b[3] * xp) * t_evaluations_1[3]
    tempvar sum = sum + (constraint_coeffs.transition_a[4] + constraint_coeffs.transition_b[4] * xp) * t_evaluations_1[4]
    tempvar sum = sum + (constraint_coeffs.transition_a[5] + constraint_coeffs.transition_b[5] * xp) * t_evaluations_1[5]
    tempvar sum = sum + (constraint_coeffs.transition_a[6] + constraint_coeffs.transition_b[6] * xp) * t_evaluations_1[6]
    tempvar sum = sum + (constraint_coeffs.transition_a[7] + constraint_coeffs.transition_b[7] * xp) * t_evaluations_1[7]
    tempvar sum = sum + (constraint_coeffs.transition_a[8] + constraint_coeffs.transition_b[8] * xp) * t_evaluations_1[8]
    tempvar sum = sum + (constraint_coeffs.transition_a[9] + constraint_coeffs.transition_b[9] * xp) * t_evaluations_1[9]
    tempvar sum = sum + (constraint_coeffs.transition_a[10] + constraint_coeffs.transition_b[10] * xp) * t_evaluations_1[10]
    tempvar sum = sum + (constraint_coeffs.transition_a[11] + constraint_coeffs.transition_b[11] * xp) * t_evaluations_1[11]
    tempvar sum = sum + (constraint_coeffs.transition_a[12] + constraint_coeffs.transition_b[12] * xp) * t_evaluations_1[12]
    tempvar sum = sum + (constraint_coeffs.transition_a[13] + constraint_coeffs.transition_b[13] * xp) * t_evaluations_1[13]
    tempvar sum = sum + (constraint_coeffs.transition_a[14] + constraint_coeffs.transition_b[14] * xp) * t_evaluations_1[14]

    // Merge evaluations for degree 4 constraints
    tempvar evaluation_degree = composition_degree - 4 * air.context.trace_length;
    tempvar degree_adjustment = target_degree - evaluation_degree;
    tempvar xp = pow(x, degree_adjustment);
    tempvar sum = sum + (constraint_coeffs.transition_a[16] + constraint_coeffs.transition_b[16] * xp) * t_evaluations_1[16]
    tempvar sum = sum + (constraint_coeffs.transition_a[17] + constraint_coeffs.transition_b[17] * xp) * t_evaluations_1[17]
    tempvar sum = sum + (constraint_coeffs.transition_a[18] + constraint_coeffs.transition_b[18] * xp) * t_evaluations_1[18]
    tempvar sum = sum + (constraint_coeffs.transition_a[19] + constraint_coeffs.transition_b[19] * xp) * t_evaluations_1[19]
    tempvar sum = sum + (constraint_coeffs.transition_a[20] + constraint_coeffs.transition_b[20] * xp) * t_evaluations_1[20]
    tempvar sum = sum + (constraint_coeffs.transition_a[21] + constraint_coeffs.transition_b[21] * xp) * t_evaluations_1[21]
    tempvar sum = sum + (constraint_coeffs.transition_a[22] + constraint_coeffs.transition_b[22] * xp) * t_evaluations_1[22]
    tempvar sum = sum + (constraint_coeffs.transition_a[23] + constraint_coeffs.transition_b[23] * xp) * t_evaluations_1[23]
    tempvar sum = sum + (constraint_coeffs.transition_a[24] + constraint_coeffs.transition_b[24] * xp) * t_evaluations_1[24]
    tempvar sum = sum + (constraint_coeffs.transition_a[25] + constraint_coeffs.transition_b[25] * xp) * t_evaluations_1[25]
    tempvar sum = sum + (constraint_coeffs.transition_a[26] + constraint_coeffs.transition_b[26] * xp) * t_evaluations_1[26]
    tempvar sum = sum + (constraint_coeffs.transition_a[27] + constraint_coeffs.transition_b[27] * xp) * t_evaluations_1[27]
    tempvar sum = sum + (constraint_coeffs.transition_a[28] + constraint_coeffs.transition_b[28] * xp) * t_evaluations_1[28]
    tempvar sum = sum + (constraint_coeffs.transition_a[29] + constraint_coeffs.transition_b[29] * xp) * t_evaluations_1[29]
    tempvar sum = sum + (constraint_coeffs.transition_a[30] + constraint_coeffs.transition_b[30] * xp) * t_evaluations_1[30]

    // TODO: Merge evaluations for auxiliary constraints

    // Divide by divisor evaluation. We can do this once at the end of merging because 
    // the divisor is identical for all constraints
    tempvar sum = sum / z;

    return total_sum;
}
