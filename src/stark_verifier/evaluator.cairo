from starkware.cairo.common.alloc import alloc
from starkware.cairo.common.pow import pow
from stark_verifier.air.air_instance import AirInstance, ConstraintCompositionCoefficients
from stark_verifier.air.transitions.frame import (
    EvaluationFrame,
    evaluate_transition,
    evaluate_aux_transition,
)

// TODO: Functions to evaluate transitions and combine evaluation should be autogenerated
// from a constraint description language instead of hand-coded.
func evaluate_constraints{
    range_check_ptr
    }(
    air: AirInstance,
    constraint_coeffs: ConstraintCompositionCoefficients,
    ood_main_trace_frame: EvaluationFrame,
    ood_aux_trace_frame: EvaluationFrame,
    aux_trace_rand_elements: felt*,
    z: felt,
) -> felt {
    alloc_locals;

    // Evaluate main trace
    let (t_evaluations1: felt*) = alloc();
    evaluate_transition(
        ood_main_trace_frame, 
        t_evaluations1,
    );

    // Evaluate auxiliary trace
    let (t_evaluations2: felt*) = alloc();
    evaluate_aux_transition(
        ood_main_trace_frame,
        ood_aux_trace_frame, 
        aux_trace_rand_elements,
        t_evaluations2,
    );

    // Combine evaluations
    let result = combine_evaluations(
        t_evaluations1,
        t_evaluations2,
        z,
        air,
        constraint_coeffs,
    );

    // 2 ----- evaluate boundary constraints ------------------------------------------------------
    // TODO

    return result;
}

func combine_evaluations{
        range_check_ptr
    }(
    t_evaluations1: felt*,
    t_evaluations2: felt*,
    x: felt,
    air: AirInstance,
    constraint_coeffs: ConstraintCompositionCoefficients,
) -> felt {
    alloc_locals;
    // Degrees needed to compute adjustments
    let composition_degree = air.context.trace_length * air.ce_blowup_factor;
    let divisor_degree = air.context.trace_length - 1;
    let target_degree = composition_degree + divisor_degree;

    // Evaluate divisor
    let (numerator) = pow(x, air.context.trace_length);
    let denominator = x - air.context.trace_length;
    let z = numerator / denominator;

    // Sum all constraint evaluations
    let sum = 0;

    // Merge evaluations for degree 1 constraints
    let evaluation_degree = composition_degree - air.context.trace_length;
    let degree_adjustment = target_degree - evaluation_degree;
    let (xp) = pow(x, degree_adjustment);
    let sum = sum + (constraint_coeffs.transition_a[15] + constraint_coeffs.transition_b[15] * xp) * t_evaluations1[15];

    // Merge evaluations for degree 2 constraints
    let evaluation_degree = composition_degree - 2 * air.context.trace_length;
    let degree_adjustment = target_degree - evaluation_degree;
    let (xp) = pow(x, degree_adjustment);
    let sum = sum + (constraint_coeffs.transition_a[0] + constraint_coeffs.transition_b[0] * xp) * t_evaluations1[0];
    let sum = sum + (constraint_coeffs.transition_a[1] + constraint_coeffs.transition_b[1] * xp) * t_evaluations1[1];
    let sum = sum + (constraint_coeffs.transition_a[2] + constraint_coeffs.transition_b[2] * xp) * t_evaluations1[2];
    let sum = sum + (constraint_coeffs.transition_a[3] + constraint_coeffs.transition_b[3] * xp) * t_evaluations1[3];
    let sum = sum + (constraint_coeffs.transition_a[4] + constraint_coeffs.transition_b[4] * xp) * t_evaluations1[4];
    let sum = sum + (constraint_coeffs.transition_a[5] + constraint_coeffs.transition_b[5] * xp) * t_evaluations1[5];
    let sum = sum + (constraint_coeffs.transition_a[6] + constraint_coeffs.transition_b[6] * xp) * t_evaluations1[6];
    let sum = sum + (constraint_coeffs.transition_a[7] + constraint_coeffs.transition_b[7] * xp) * t_evaluations1[7];
    let sum = sum + (constraint_coeffs.transition_a[8] + constraint_coeffs.transition_b[8] * xp) * t_evaluations1[8];
    let sum = sum + (constraint_coeffs.transition_a[9] + constraint_coeffs.transition_b[9] * xp) * t_evaluations1[9];
    let sum = sum + (constraint_coeffs.transition_a[10] + constraint_coeffs.transition_b[10] * xp) * t_evaluations1[10];
    let sum = sum + (constraint_coeffs.transition_a[11] + constraint_coeffs.transition_b[11] * xp) * t_evaluations1[11];
    let sum = sum + (constraint_coeffs.transition_a[12] + constraint_coeffs.transition_b[12] * xp) * t_evaluations1[12];
    let sum = sum + (constraint_coeffs.transition_a[13] + constraint_coeffs.transition_b[13] * xp) * t_evaluations1[13];
    let sum = sum + (constraint_coeffs.transition_a[14] + constraint_coeffs.transition_b[14] * xp) * t_evaluations1[14];

    // Merge evaluations for degree 4 constraints
    let evaluation_degree = composition_degree - 4 * air.context.trace_length;
    let degree_adjustment = target_degree - evaluation_degree;
    let (xp) = pow(x, degree_adjustment);
    let sum = sum + (constraint_coeffs.transition_a[16] + constraint_coeffs.transition_b[16] * xp) * t_evaluations1[16];
    let sum = sum + (constraint_coeffs.transition_a[17] + constraint_coeffs.transition_b[17] * xp) * t_evaluations1[17];
    let sum = sum + (constraint_coeffs.transition_a[18] + constraint_coeffs.transition_b[18] * xp) * t_evaluations1[18];
    let sum = sum + (constraint_coeffs.transition_a[19] + constraint_coeffs.transition_b[19] * xp) * t_evaluations1[19];
    let sum = sum + (constraint_coeffs.transition_a[20] + constraint_coeffs.transition_b[20] * xp) * t_evaluations1[20];
    let sum = sum + (constraint_coeffs.transition_a[21] + constraint_coeffs.transition_b[21] * xp) * t_evaluations1[21];
    let sum = sum + (constraint_coeffs.transition_a[22] + constraint_coeffs.transition_b[22] * xp) * t_evaluations1[22];
    let sum = sum + (constraint_coeffs.transition_a[23] + constraint_coeffs.transition_b[23] * xp) * t_evaluations1[23];
    let sum = sum + (constraint_coeffs.transition_a[24] + constraint_coeffs.transition_b[24] * xp) * t_evaluations1[24];
    let sum = sum + (constraint_coeffs.transition_a[25] + constraint_coeffs.transition_b[25] * xp) * t_evaluations1[25];
    let sum = sum + (constraint_coeffs.transition_a[26] + constraint_coeffs.transition_b[26] * xp) * t_evaluations1[26];
    let sum = sum + (constraint_coeffs.transition_a[27] + constraint_coeffs.transition_b[27] * xp) * t_evaluations1[27];
    let sum = sum + (constraint_coeffs.transition_a[28] + constraint_coeffs.transition_b[28] * xp) * t_evaluations1[28];
    let sum = sum + (constraint_coeffs.transition_a[29] + constraint_coeffs.transition_b[29] * xp) * t_evaluations1[29];
    let sum = sum + (constraint_coeffs.transition_a[30] + constraint_coeffs.transition_b[30] * xp) * t_evaluations1[30];



    // Merge evaluations for auxiliary constraints
    let evaluation_degree = composition_degree - 2 * air.context.trace_length;
    let degree_adjustment = target_degree - evaluation_degree;
    let (xp) = pow(x, degree_adjustment);
    

    // Merge evaluations for auxiliary constraints
    let evaluation_degree = composition_degree - 2 * air.context.trace_length;
    let degree_adjustment = target_degree - evaluation_degree;
    let (xp) = pow(x, degree_adjustment);
    
    let sum = sum + (constraint_coeffs.transition_a[31] + constraint_coeffs.transition_b[31] * xp) * t_evaluations2[0];
    let sum = sum + (constraint_coeffs.transition_a[32] + constraint_coeffs.transition_b[32] * xp) * t_evaluations2[1];
    let sum = sum + (constraint_coeffs.transition_a[33] + constraint_coeffs.transition_b[33] * xp) * t_evaluations2[2];
    let sum = sum + (constraint_coeffs.transition_a[34] + constraint_coeffs.transition_b[34] * xp) * t_evaluations2[3];
    let sum = sum + (constraint_coeffs.transition_a[35] + constraint_coeffs.transition_b[35] * xp) * t_evaluations2[4];
    let sum = sum + (constraint_coeffs.transition_a[36] + constraint_coeffs.transition_b[36] * xp) * t_evaluations2[5];
    let sum = sum + (constraint_coeffs.transition_a[37] + constraint_coeffs.transition_b[37] * xp) * t_evaluations2[6];
    let sum = sum + (constraint_coeffs.transition_a[38] + constraint_coeffs.transition_b[38] * xp) * t_evaluations2[7];
    let sum = sum + (constraint_coeffs.transition_a[39] + constraint_coeffs.transition_b[39] * xp) * t_evaluations2[8];
    let sum = sum + (constraint_coeffs.transition_a[40] + constraint_coeffs.transition_b[40] * xp) * t_evaluations2[9];
    let sum = sum + (constraint_coeffs.transition_a[41] + constraint_coeffs.transition_b[41] * xp) * t_evaluations2[10];
    let sum = sum + (constraint_coeffs.transition_a[42] + constraint_coeffs.transition_b[42] * xp) * t_evaluations2[11];
    let sum = sum + (constraint_coeffs.transition_a[43] + constraint_coeffs.transition_b[43] * xp) * t_evaluations2[12];
    let sum = sum + (constraint_coeffs.transition_a[44] + constraint_coeffs.transition_b[44] * xp) * t_evaluations2[13];
    let sum = sum + (constraint_coeffs.transition_a[45] + constraint_coeffs.transition_b[45] * xp) * t_evaluations2[14];
    let sum = sum + (constraint_coeffs.transition_a[46] + constraint_coeffs.transition_b[46] * xp) * t_evaluations2[15];
    let sum = sum + (constraint_coeffs.transition_a[47] + constraint_coeffs.transition_b[47] * xp) * t_evaluations2[16];
    let sum = sum + (constraint_coeffs.transition_a[48] + constraint_coeffs.transition_b[48] * xp) * t_evaluations2[17];



    // Divide by divisor evaluation. We can do this once at the end of merging because 
    // the divisor is identical for all constraints
    let sum = sum / z;

    return sum;
}
